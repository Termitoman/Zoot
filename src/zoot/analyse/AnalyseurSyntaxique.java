//----------------------------------------------------
// The following code was generated by CUP v0.11a beta 20060608
// Thu Mar 31 12:15:19 CEST 2022
//----------------------------------------------------

package zoot.analyse;

import zoot.arbre.ArbreAbstrait;
import zoot.arbre.BlocDInstructions;
import zoot.arbre.expressions.*;
import zoot.arbre.expressions.operateurs.binaires.*;
import zoot.arbre.expressions.operateurs.unaires.Moins;
import zoot.arbre.expressions.operateurs.unaires.Non;
import zoot.arbre.expressions.operateurs.unaires.Parenthese;
import zoot.arbre.fonctions.Fonction;
import zoot.arbre.fonctions.GestionnaireFonctions;
import zoot.arbre.instructions.*;
import zoot.exceptions.AnalyseSyntaxiqueException;
import zoot.exceptions.DoubleDeclarationException;
import zoot.gestionErreurs.Erreur;
import zoot.gestionErreurs.StockageErreurs;
import zoot.tableDesSymboles.Entree;
import zoot.tableDesSymboles.Symbole;
import zoot.tableDesSymboles.TDS;

import java.util.ArrayList;
import java.util.HashMap;

/**
 * CUP v0.11a beta 20060608 generated parser.
 *
 * @version Thu Mar 31 12:15:19 CEST 2022
 */
public class AnalyseurSyntaxique extends java_cup.runtime.lr_parser {

    /**
     * Default constructor.
     */
    public AnalyseurSyntaxique() {
        super();
    }

    /**
     * Constructor which sets the default scanner.
     */
    public AnalyseurSyntaxique(java_cup.runtime.Scanner s) {
        super(s);
    }

    /**
     * Constructor which sets the default scanner.
     */
    public AnalyseurSyntaxique(java_cup.runtime.Scanner s, java_cup.runtime.SymbolFactory sf) {
        super(s, sf);
    }

    /**
     * Production table.
     */
    protected static final short[][] _production_table =
            unpackFromStrings(new String[]{
                    "\000\056\000\002\002\004\000\002\002\011\000\002\004" +
                            "\004\000\002\004\003\000\002\003\004\000\002\003\003" +
                            "\000\002\005\004\000\002\005\003\000\002\016\004\000" +
                            "\002\016\003\000\002\010\004\000\002\010\003\000\002" +
                            "\012\005\000\002\012\006\000\002\012\005\000\002\012" +
                            "\011\000\002\012\010\000\002\012\007\000\002\012\006" +
                            "\000\002\012\007\000\002\013\003\000\002\013\003\000" +
                            "\002\013\003\000\002\013\005\000\002\013\006\000\002" +
                            "\013\005\000\002\013\005\000\002\013\005\000\002\013" +
                            "\005\000\002\013\005\000\002\013\004\000\002\013\004" +
                            "\000\002\013\005\000\002\013\005\000\002\013\005\000" +
                            "\002\020\005\000\002\020\003\000\002\014\003\000\002" +
                            "\014\003\000\002\006\005\000\002\017\005\000\002\011" +
                            "\005\000\002\015\004\000\002\015\005\000\002\007\011" +
                            "\000\002\007\012"});

    /**
     * Access to production table.
     */
    public short[][] production_table() {
        return _production_table;
    }

    /**
     * Parse-action table.
     */
    protected static final short[][] _action_table =
            unpackFromStrings(new String[]{
                    "\000\150\000\004\006\005\001\002\000\004\002\152\001" +
                            "\002\000\006\042\010\043\011\001\002\000\010\013\016" +
                            "\042\010\043\011\001\002\000\010\013\ufffe\042\ufffe\043" +
                            "\ufffe\001\002\000\004\037\uffdb\001\002\000\004\037\uffdc" +
                            "\001\002\000\004\037\013\001\002\000\004\007\014\001" +
                            "\002\000\010\013\uffda\042\uffda\043\uffda\001\002\000\010" +
                            "\013\uffff\042\uffff\043\uffff\001\002\000\006\042\010\043" +
                            "\011\001\002\000\010\004\ufffa\042\ufffa\043\ufffa\001\002" +
                            "\000\010\004\146\042\010\043\011\001\002\000\004\037" +
                            "\022\001\002\000\004\014\024\001\002\000\004\006\035" +
                            "\001\002\000\010\015\027\042\010\043\011\001\002\000" +
                            "\010\015\ufff8\042\ufff8\043\ufff8\001\002\000\010\015\034" +
                            "\042\010\043\011\001\002\000\004\006\uffd7\001\002\000" +
                            "\004\037\031\001\002\000\004\007\032\001\002\000\010" +
                            "\015\uffd9\042\uffd9\043\uffd9\001\002\000\010\015\ufff9\042" +
                            "\ufff9\043\ufff9\001\002\000\004\006\uffd6\001\002\000\010" +
                            "\004\036\042\010\043\011\001\002\000\014\011\054\016" +
                            "\051\030\052\034\046\037\050\001\002\000\010\004\ufff6" +
                            "\042\ufff6\043\ufff6\001\002\000\010\004\044\042\010\043" +
                            "\011\001\002\000\004\037\042\001\002\000\004\007\043" +
                            "\001\002\000\010\004\uffd8\042\uffd8\043\uffd8\001\002\000" +
                            "\014\011\054\016\051\030\052\034\046\037\050\001\002" +
                            "\000\010\004\ufff7\042\ufff7\043\ufff7\001\002\000\014\011" +
                            "\054\016\051\030\052\034\046\037\050\001\002\000\024" +
                            "\005\ufffc\011\ufffc\016\ufffc\030\ufffc\032\ufffc\033\ufffc\034" +
                            "\ufffc\035\ufffc\037\ufffc\001\002\000\004\012\135\001\002" +
                            "\000\016\014\063\021\060\024\062\037\056\040\055\041" +
                            "\057\001\002\000\016\014\063\021\060\024\062\037\056" +
                            "\040\055\041\057\001\002\000\016\005\117\011\054\016" +
                            "\051\030\052\034\046\037\050\001\002\000\016\014\063" +
                            "\021\060\024\062\037\056\040\055\041\057\001\002\000" +
                            "\032\007\uffed\010\uffed\015\uffed\017\uffed\020\uffed\022\uffed" +
                            "\023\uffed\025\uffed\026\uffed\027\uffed\031\uffed\036\uffed\001" +
                            "\002\000\034\007\uffeb\010\uffeb\014\107\015\uffeb\017\uffeb" +
                            "\020\uffeb\022\uffeb\023\uffeb\025\uffeb\026\uffeb\027\uffeb\031" +
                            "\uffeb\036\uffeb\001\002\000\032\007\uffec\010\uffec\015\uffec" +
                            "\017\uffec\020\uffec\022\uffec\023\uffec\025\uffec\026\uffec\027" +
                            "\uffec\031\uffec\036\uffec\001\002\000\016\014\063\021\060" +
                            "\024\062\037\056\040\055\041\057\001\002\000\022\007" +
                            "\105\017\070\020\066\022\074\023\071\025\065\026\072" +
                            "\027\067\001\002\000\016\014\063\021\060\024\062\037" +
                            "\056\040\055\041\057\001\002\000\016\014\063\021\060" +
                            "\024\062\037\056\040\055\041\057\001\002\000\022\015" +
                            "\073\017\070\020\066\022\074\023\071\025\065\026\072" +
                            "\027\067\001\002\000\016\014\063\021\060\024\062\037" +
                            "\056\040\055\041\057\001\002\000\016\014\063\021\060" +
                            "\024\062\037\056\040\055\041\057\001\002\000\016\014" +
                            "\063\021\060\024\062\037\056\040\055\041\057\001\002" +
                            "\000\016\014\063\021\060\024\062\037\056\040\055\041" +
                            "\057\001\002\000\016\014\063\021\060\024\062\037\056" +
                            "\040\055\041\057\001\002\000\016\014\063\021\060\024" +
                            "\062\037\056\040\055\041\057\001\002\000\032\007\uffdf" +
                            "\010\uffdf\015\uffdf\017\uffdf\020\uffdf\022\uffdf\023\uffdf\025" +
                            "\uffdf\026\uffdf\027\uffdf\031\uffdf\036\uffdf\001\002\000\016" +
                            "\014\063\021\060\024\062\037\056\040\055\041\057\001" +
                            "\002\000\032\007\uffe1\010\uffe1\015\uffe1\017\070\020\066" +
                            "\022\uffe1\023\uffe1\025\065\026\072\027\067\031\uffe1\036" +
                            "\uffe1\001\002\000\032\007\uffe8\010\uffe8\015\uffe8\017\070" +
                            "\020\066\022\uffe8\023\uffe8\025\065\026\uffe8\027\067\031" +
                            "\uffe8\036\uffe8\001\002\000\032\007\uffe0\010\uffe0\015\uffe0" +
                            "\017\070\020\066\022\074\023\uffe0\025\065\026\072\027" +
                            "\067\031\uffe0\036\uffe0\001\002\000\032\007\uffe5\010\uffe5" +
                            "\015\uffe5\017\uffe5\020\066\022\uffe5\023\uffe5\025\uffe5\026" +
                            "\uffe5\027\uffe5\031\uffe5\036\uffe5\001\002\000\032\007\uffe6" +
                            "\010\uffe6\015\uffe6\017\070\020\066\022\uffe6\023\uffe6\025" +
                            "\uffe6\026\uffe6\027\uffe6\031\uffe6\036\uffe6\001\002\000\032" +
                            "\007\uffe4\010\uffe4\015\uffe4\017\uffe4\020\uffe4\022\uffe4\023" +
                            "\uffe4\025\uffe4\026\uffe4\027\uffe4\031\uffe4\036\uffe4\001\002" +
                            "\000\032\007\uffe7\010\uffe7\015\uffe7\017\070\020\066\022" +
                            "\uffe7\023\uffe7\025\uffe7\026\uffe7\027\067\031\uffe7\036\uffe7" +
                            "\001\002\000\032\007\uffe2\010\uffe2\015\uffe2\017\uffe2\020" +
                            "\uffe2\022\uffe2\023\uffe2\025\uffe2\026\uffe2\027\uffe2\031\uffe2" +
                            "\036\uffe2\001\002\000\024\005\ufff5\011\ufff5\016\ufff5\030" +
                            "\ufff5\032\ufff5\033\ufff5\034\ufff5\035\ufff5\037\ufff5\001\002" +
                            "\000\032\007\uffe3\010\uffe3\015\uffe3\017\uffe3\020\uffe3\022" +
                            "\uffe3\023\uffe3\025\uffe3\026\uffe3\027\uffe3\031\uffe3\036\uffe3" +
                            "\001\002\000\020\014\063\015\111\021\060\024\062\037" +
                            "\056\040\055\041\057\001\002\000\006\010\113\015\114" +
                            "\001\002\000\032\007\uffea\010\uffea\015\uffea\017\uffea\020" +
                            "\uffea\022\uffea\023\uffea\025\uffea\026\uffea\027\uffea\031\uffea" +
                            "\036\uffea\001\002\000\024\010\uffdd\015\uffdd\017\070\020" +
                            "\066\022\074\023\071\025\065\026\072\027\067\001\002" +
                            "\000\016\014\063\021\060\024\062\037\056\040\055\041" +
                            "\057\001\002\000\032\007\uffe9\010\uffe9\015\uffe9\017\uffe9" +
                            "\020\uffe9\022\uffe9\023\uffe9\025\uffe9\026\uffe9\027\uffe9\031" +
                            "\uffe9\036\uffe9\001\002\000\024\010\uffde\015\uffde\017\070" +
                            "\020\066\022\074\023\071\025\065\026\072\027\067\001" +
                            "\002\000\024\005\ufffd\011\ufffd\016\ufffd\030\ufffd\032\ufffd" +
                            "\033\ufffd\034\ufffd\035\ufffd\037\ufffd\001\002\000\010\004" +
                            "\uffd4\042\uffd4\043\uffd4\001\002\000\022\017\070\020\066" +
                            "\022\074\023\071\025\065\026\072\027\067\031\121\001" +
                            "\002\000\020\011\054\016\051\030\052\032\124\033\123" +
                            "\034\046\037\050\001\002\000\020\011\054\016\051\030" +
                            "\052\032\127\033\130\034\046\037\050\001\002\000\024" +
                            "\005\uffef\011\uffef\016\uffef\030\uffef\032\uffef\033\uffef\034" +
                            "\uffef\035\uffef\037\uffef\001\002\000\014\011\054\016\051" +
                            "\030\052\034\046\037\050\001\002\000\016\011\054\016" +
                            "\051\030\052\033\126\034\046\037\050\001\002\000\024" +
                            "\005\ufff1\011\ufff1\016\ufff1\030\ufff1\032\ufff1\033\ufff1\034" +
                            "\ufff1\035\ufff1\037\ufff1\001\002\000\014\011\054\016\051" +
                            "\030\052\034\046\037\050\001\002\000\024\005\ufff0\011" +
                            "\ufff0\016\ufff0\030\ufff0\032\ufff0\033\ufff0\034\ufff0\035\ufff0" +
                            "\037\ufff0\001\002\000\016\011\054\016\051\030\052\033" +
                            "\132\034\046\037\050\001\002\000\024\005\ufff2\011\ufff2" +
                            "\016\ufff2\030\ufff2\032\ufff2\033\ufff2\034\ufff2\035\ufff2\037" +
                            "\ufff2\001\002\000\022\007\134\017\070\020\066\022\074" +
                            "\023\071\025\065\026\072\027\067\001\002\000\024\005" +
                            "\ufff3\011\ufff3\016\ufff3\030\ufff3\032\ufff3\033\ufff3\034\ufff3" +
                            "\035\ufff3\037\ufff3\001\002\000\016\014\063\021\060\024" +
                            "\062\037\056\040\055\041\057\001\002\000\022\007\137" +
                            "\017\070\020\066\022\074\023\071\025\065\026\072\027" +
                            "\067\001\002\000\024\005\ufff4\011\ufff4\016\ufff4\030\ufff4" +
                            "\032\ufff4\033\ufff4\034\ufff4\035\ufff4\037\ufff4\001\002\000" +
                            "\016\011\054\016\051\030\052\034\046\035\141\037\050" +
                            "\001\002\000\016\014\063\021\060\024\062\037\056\040" +
                            "\055\041\057\001\002\000\022\017\070\020\066\022\074" +
                            "\023\071\025\065\026\072\027\067\036\143\001\002\000" +
                            "\024\005\uffee\011\uffee\016\uffee\030\uffee\032\uffee\033\uffee" +
                            "\034\uffee\035\uffee\037\uffee\001\002\000\016\005\145\011" +
                            "\054\016\051\030\052\034\046\037\050\001\002\000\010" +
                            "\004\uffd5\042\uffd5\043\uffd5\001\002\000\014\011\054\016" +
                            "\051\030\052\034\046\037\050\001\002\000\010\004\ufffb" +
                            "\042\ufffb\043\ufffb\001\002\000\016\005\151\011\054\016" +
                            "\051\030\052\034\046\037\050\001\002\000\004\002\000" +
                            "\001\002\000\004\002\001\001\002"});

    /**
     * Access to parse-action table.
     */
    public short[][] action_table() {
        return _action_table;
    }

    /**
     * <code>reduce_goto</code> table.
     */
    protected static final short[][] _reduce_table =
            unpackFromStrings(new String[]{
                    "\000\150\000\004\002\003\001\001\000\002\001\001\000" +
                            "\010\004\005\006\006\014\011\001\001\000\006\006\014" +
                            "\014\011\001\001\000\002\001\001\000\002\001\001\000" +
                            "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
                            "\001\001\000\002\001\001\000\010\005\017\007\016\014" +
                            "\020\001\001\000\002\001\001\000\006\007\146\014\020" +
                            "\001\001\000\002\001\001\000\004\015\022\001\001\000" +
                            "\002\001\001\000\010\014\027\016\025\017\024\001\001" +
                            "\000\002\001\001\000\006\014\027\017\032\001\001\000" +
                            "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
                            "\001\001\000\002\001\001\000\002\001\001\000\010\010" +
                            "\037\011\036\014\040\001\001\000\006\003\143\012\046" +
                            "\001\001\000\002\001\001\000\006\011\044\014\040\001" +
                            "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
                            "\000\006\003\052\012\046\001\001\000\002\001\001\000" +
                            "\006\003\137\012\046\001\001\000\002\001\001\000\002" +
                            "\001\001\000\004\013\132\001\001\000\004\013\117\001" +
                            "\001\000\004\012\115\001\001\000\004\013\060\001\001" +
                            "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
                            "\004\013\105\001\001\000\002\001\001\000\004\013\103" +
                            "\001\001\000\004\013\063\001\001\000\002\001\001\000" +
                            "\004\013\102\001\001\000\004\013\101\001\001\000\004" +
                            "\013\100\001\001\000\004\013\077\001\001\000\004\013" +
                            "\076\001\001\000\004\013\075\001\001\000\002\001\001" +
                            "\000\004\013\074\001\001\000\002\001\001\000\002\001" +
                            "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
                            "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
                            "\002\001\001\000\002\001\001\000\006\013\111\020\107" +
                            "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
                            "\001\000\004\013\114\001\001\000\002\001\001\000\002" +
                            "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
                            "\001\000\006\003\121\012\046\001\001\000\004\012\115" +
                            "\001\001\000\002\001\001\000\006\003\124\012\046\001" +
                            "\001\000\004\012\115\001\001\000\002\001\001\000\006" +
                            "\003\130\012\046\001\001\000\002\001\001\000\004\012" +
                            "\115\001\001\000\002\001\001\000\002\001\001\000\002" +
                            "\001\001\000\004\013\135\001\001\000\002\001\001\000" +
                            "\002\001\001\000\004\012\115\001\001\000\004\013\141" +
                            "\001\001\000\002\001\001\000\002\001\001\000\004\012" +
                            "\115\001\001\000\002\001\001\000\006\003\147\012\046" +
                            "\001\001\000\002\001\001\000\004\012\115\001\001\000" +
                            "\002\001\001\000\002\001\001"});

    /**
     * Access to <code>reduce_goto</code> table.
     */
    public short[][] reduce_table() {
        return _reduce_table;
    }

    /**
     * Instance of action encapsulation class.
     */
    protected CUP$AnalyseurSyntaxique$actions action_obj;

    /**
     * Action encapsulation object initializer.
     */
    protected void init_actions() {
        action_obj = new CUP$AnalyseurSyntaxique$actions(this);
    }

    /**
     * Invoke a user supplied parse action.
     */
    public java_cup.runtime.Symbol do_action(
            int act_num,
            java_cup.runtime.lr_parser parser,
            java.util.Stack stack,
            int top)
            throws java.lang.Exception {
        /* call code in generated class */
        return action_obj.CUP$AnalyseurSyntaxique$do_action(act_num, parser, stack, top);
    }

    /**
     * Indicates start state.
     */
    public int start_state() {
        return 0;
    }

    /**
     * Indicates start production.
     */
    public int start_production() {
        return 0;
    }

    /**
     * <code>EOF</code> Symbol index.
     */
    public int EOF_sym() {
        return 0;
    }

    /**
     * <code>error</code> Symbol index.
     */
    public int error_sym() {
        return 1;
    }


    public void report_error(String message, Object info) {

        HashMap<Integer, String> lesTerminaux = new HashMap<>();

        lesTerminaux.put(new Integer(CodesLexicaux.DEBUT), "debut");
        lesTerminaux.put(new Integer(CodesLexicaux.FIN), "fin");
        lesTerminaux.put(new Integer(CodesLexicaux.POINTVIRGULE), ";");

        StringBuffer m = new StringBuffer();

        if (info instanceof java_cup.runtime.Symbol) {
            java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);

            if (s.left >= 0) {
                m.append("\tligne : " + (s.left + 1));
                if (s.right >= 0)
                    m.append(" colonne : " + (s.right + 1));
            }

            if (s.value != null) {
                lesTerminaux.put(CodesLexicaux.CSTENTIERE, "" + s.value);
            }

            if (lesTerminaux.containsKey(new Integer(s.sym))) {
                m.append(" dernier token lu : " + lesTerminaux.get(new Integer(s.sym)));
            } else {
                m.append(" expression non terminée");
            }

        }
        throw new AnalyseSyntaxiqueException("" + m);
    }

    public void report_fatal_error(String message, Object info) {
        report_error(message, info);
    }

}

/**
 * Cup generated class to encapsulate user supplied action code.
 */
class CUP$AnalyseurSyntaxique$actions {


    private final AnalyseurSyntaxique parser;

    /**
     * Constructor
     */
    CUP$AnalyseurSyntaxique$actions(AnalyseurSyntaxique parser) {
        this.parser = parser;
    }

    /**
     * Method with the actual generated action code.
     */
    public final java_cup.runtime.Symbol CUP$AnalyseurSyntaxique$do_action(
            int CUP$AnalyseurSyntaxique$act_num,
            java_cup.runtime.lr_parser CUP$AnalyseurSyntaxique$parser,
            java.util.Stack CUP$AnalyseurSyntaxique$stack,
            int CUP$AnalyseurSyntaxique$top)
            throws java.lang.Exception {
        /* Symbol object for return from actions */
        java_cup.runtime.Symbol CUP$AnalyseurSyntaxique$result;

        /* select the action based on the action number */
        switch (CUP$AnalyseurSyntaxique$act_num) {
            /*. . . . . . . . . . . . . . . . . . . .*/
            case 45: // FONC ::= TYPE IDF PARAM VARIABLES LDECL_LOC DEBUT LINST FIN
            {
                ArbreAbstrait RESULT = null;
                int tleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 7)).left;
                int tright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 7)).right;
                String t = (String) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 7)).value;
                int ileft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 6)).left;
                int iright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 6)).right;
                String i = (String) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 6)).value;
                int pleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 5)).left;
                int pright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 5)).right;
                String p = (String) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 5)).value;
                int ldlleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 3)).left;
                int ldlright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 3)).right;
                ArbreAbstrait ldl = (ArbreAbstrait) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 3)).value;
                int lileft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).left;
                int liright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).right;
                ArbreAbstrait li = (ArbreAbstrait) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).value;

                int noBlocFonc = TDS.getInstance().getNoBlocActuel();
                TDS.getInstance().sortieBloc();
                String[] params = p.split(",");
                ArrayList<String> typeParams = new ArrayList<>();
                ArrayList<String> nomParams = new ArrayList<>();
                for (String s : params) {
                    if (s.equals("entier") || s.equals("booleen"))
                        typeParams.add(s);
                    else
                        nomParams.add(s);
                }
                GestionnaireFonctions.getInstance().ajouter(new Fonction(ileft + 1, i, li, typeParams, nomParams, noBlocFonc));
                try {
                    TDS.getInstance().ajouter(new Entree(i, "fonction", typeParams), new Symbole(t));
                } catch (DoubleDeclarationException e) {
                    StockageErreurs.getInstance().ajouter(new Erreur(e.getMessage(), ileft + 1));
                }

                CUP$AnalyseurSyntaxique$result = parser.getSymbolFactory().newSymbol("FONC", 5, ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 7)), ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), RESULT);
            }
            return CUP$AnalyseurSyntaxique$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 44: // FONC ::= TYPE IDF PARAM VARIABLES DEBUT LINST FIN
            {
                ArbreAbstrait RESULT = null;
                int tleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 6)).left;
                int tright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 6)).right;
                String t = (String) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 6)).value;
                int ileft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 5)).left;
                int iright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 5)).right;
                String i = (String) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 5)).value;
                int pleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 4)).left;
                int pright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 4)).right;
                String p = (String) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 4)).value;
                int lileft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).left;
                int liright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).right;
                ArbreAbstrait li = (ArbreAbstrait) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).value;

                int noBlocFonc = TDS.getInstance().getNoBlocActuel();
                TDS.getInstance().sortieBloc();
                String[] params = p.split(",");
                ArrayList<String> typeParams = new ArrayList<>();
                ArrayList<String> nomParams = new ArrayList<>();
                for (String s : params) {
                    if (s.equals("entier") || s.equals("booleen"))
                        typeParams.add(s);
                    else
                        nomParams.add(s);
                }
                GestionnaireFonctions.getInstance().ajouter(new Fonction(ileft + 1, i, li, typeParams, nomParams, noBlocFonc));
                try {
                    TDS.getInstance().ajouter(new Entree(i, "fonction", typeParams), new Symbole(t));
                } catch (DoubleDeclarationException e) {
                    StockageErreurs.getInstance().ajouter(new Erreur(e.getMessage(), ileft + 1));
                }

                CUP$AnalyseurSyntaxique$result = parser.getSymbolFactory().newSymbol("FONC", 5, ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 6)), ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), RESULT);
            }
            return CUP$AnalyseurSyntaxique$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 43: // PARAM ::= PAROUVRANTE LDECL_PARAM PARFERMANTE
            {
                String RESULT = null;
                int ldleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).left;
                int ldright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).right;
                String ld = (String) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).value;
                RESULT = ld;
                CUP$AnalyseurSyntaxique$result = parser.getSymbolFactory().newSymbol("PARAM", 11, ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 2)), ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), RESULT);
            }
            return CUP$AnalyseurSyntaxique$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 42: // PARAM ::= PAROUVRANTE PARFERMANTE
            {
                String RESULT = null;

                TDS tds = TDS.getInstance();
                if (tds.getNoBlocActuel() == 0) {
                    tds.entreeBloc();
                }
                RESULT = "";

                CUP$AnalyseurSyntaxique$result = parser.getSymbolFactory().newSymbol("PARAM", 11, ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)), ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), RESULT);
            }
            return CUP$AnalyseurSyntaxique$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 41: // DECL_LOC ::= TYPE IDF POINTVIRGULE
            {
                ArbreAbstrait RESULT = null;
                int tleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 2)).left;
                int tright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 2)).right;
                String t = (String) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 2)).value;
                int ileft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).left;
                int iright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).right;
                String i = (String) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).value;

                try {
                    TDS.getInstance().ajouter(new Entree(i, "variable"), new Symbole(t));
                } catch (DoubleDeclarationException e) {
                    StockageErreurs.getInstance().ajouter(new Erreur(e.getMessage(), ileft + 1));
                }

                CUP$AnalyseurSyntaxique$result = parser.getSymbolFactory().newSymbol("DECL_LOC", 7, ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 2)), ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), RESULT);
            }
            return CUP$AnalyseurSyntaxique$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 40: // DECL_PARAM ::= TYPE IDF POINTVIRGULE
            {
                String RESULT = null;
                int tleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 2)).left;
                int tright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 2)).right;
                String t = (String) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 2)).value;
                int ileft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).left;
                int iright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).right;
                String i = (String) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).value;

                TDS tds = TDS.getInstance();
                if (tds.getNoBlocActuel() == 0) {
                    tds.entreeBloc();
                }
                try {
                    tds.ajouter(new Entree(i, "variable"), new Symbole(t));
                } catch (DoubleDeclarationException e) {
                    StockageErreurs.getInstance().ajouter(new Erreur(e.getMessage(), ileft + 1));
                }
                RESULT = t + "," + i;

                CUP$AnalyseurSyntaxique$result = parser.getSymbolFactory().newSymbol("DECL_PARAM", 13, ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 2)), ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), RESULT);
            }
            return CUP$AnalyseurSyntaxique$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 39: // DECL ::= TYPE IDF POINTVIRGULE
            {
                ArbreAbstrait RESULT = null;
                int tleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 2)).left;
                int tright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 2)).right;
                String t = (String) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 2)).value;
                int ileft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).left;
                int iright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).right;
                String i = (String) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).value;

                try {
                    TDS.getInstance().ajouter(new Entree(i, "variable"), new Symbole(t));
                } catch (DoubleDeclarationException e) {
                    StockageErreurs.getInstance().ajouter(new Erreur(e.getMessage(), ileft + 1));
                }

                CUP$AnalyseurSyntaxique$result = parser.getSymbolFactory().newSymbol("DECL", 4, ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 2)), ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), RESULT);
            }
            return CUP$AnalyseurSyntaxique$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 38: // TYPE ::= BOOLEEN
            {
                String RESULT = null;
                RESULT = "booleen";
                CUP$AnalyseurSyntaxique$result = parser.getSymbolFactory().newSymbol("TYPE", 10, ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), RESULT);
            }
            return CUP$AnalyseurSyntaxique$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 37: // TYPE ::= ENTIER
            {
                String RESULT = null;
                RESULT = "entier";
                CUP$AnalyseurSyntaxique$result = parser.getSymbolFactory().newSymbol("TYPE", 10, ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), RESULT);
            }
            return CUP$AnalyseurSyntaxique$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 36: // LEXP ::= EXP
            {
                ArrayList<Expression> RESULT = null;
                int eleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).left;
                int eright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).right;
                Expression e = (Expression) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).value;
                ArrayList<Expression> a = new ArrayList<>();
                a.add(e);
                RESULT = a;
                CUP$AnalyseurSyntaxique$result = parser.getSymbolFactory().newSymbol("LEXP", 14, ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), RESULT);
            }
            return CUP$AnalyseurSyntaxique$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 35: // LEXP ::= LEXP VIRGULE EXP
            {
                ArrayList<Expression> RESULT = null;
                int leleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 2)).left;
                int leright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 2)).right;
                ArrayList<Expression> le = (ArrayList<Expression>) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 2)).value;
                int eleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).left;
                int eright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).right;
                Expression e = (Expression) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).value;
                le.add(e);
                RESULT = le;
                CUP$AnalyseurSyntaxique$result = parser.getSymbolFactory().newSymbol("LEXP", 14, ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 2)), ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), RESULT);
            }
            return CUP$AnalyseurSyntaxique$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 34: // EXP ::= PAROUVRANTE EXP PARFERMANTE
            {
                Expression RESULT = null;
                int eleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).left;
                int eright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).right;
                Expression e = (Expression) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).value;
                RESULT = new Parenthese(eleft + 1, e);
                CUP$AnalyseurSyntaxique$result = parser.getSymbolFactory().newSymbol("EXP", 9, ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 2)), ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), RESULT);
            }
            return CUP$AnalyseurSyntaxique$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 33: // EXP ::= EXP OU EXP
            {
                Expression RESULT = null;
                int egleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 2)).left;
                int egright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 2)).right;
                Expression eg = (Expression) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 2)).value;
                int edleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).left;
                int edright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).right;
                Expression ed = (Expression) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).value;
                RESULT = new Ou(egleft + 1, eg, ed);
                CUP$AnalyseurSyntaxique$result = parser.getSymbolFactory().newSymbol("EXP", 9, ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 2)), ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), RESULT);
            }
            return CUP$AnalyseurSyntaxique$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 32: // EXP ::= EXP ET EXP
            {
                Expression RESULT = null;
                int egleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 2)).left;
                int egright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 2)).right;
                Expression eg = (Expression) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 2)).value;
                int edleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).left;
                int edright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).right;
                Expression ed = (Expression) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).value;
                RESULT = new Et(egleft + 1, eg, ed);
                CUP$AnalyseurSyntaxique$result = parser.getSymbolFactory().newSymbol("EXP", 9, ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 2)), ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), RESULT);
            }
            return CUP$AnalyseurSyntaxique$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 31: // EXP ::= NON EXP
            {
                Expression RESULT = null;
                int eleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).left;
                int eright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).right;
                Expression e = (Expression) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).value;
                RESULT = new Non(eleft + 1, e);
                CUP$AnalyseurSyntaxique$result = parser.getSymbolFactory().newSymbol("EXP", 9, ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)), ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), RESULT);
            }
            return CUP$AnalyseurSyntaxique$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 30: // EXP ::= MOINS EXP
            {
                Expression RESULT = null;
                int eleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).left;
                int eright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).right;
                Expression e = (Expression) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).value;
                RESULT = new Moins(eleft + 1, e);
                CUP$AnalyseurSyntaxique$result = parser.getSymbolFactory().newSymbol("EXP", 9, ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)), ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), RESULT);
            }
            return CUP$AnalyseurSyntaxique$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 29: // EXP ::= EXP MULT EXP
            {
                Expression RESULT = null;
                int egleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 2)).left;
                int egright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 2)).right;
                Expression eg = (Expression) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 2)).value;
                int edleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).left;
                int edright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).right;
                Expression ed = (Expression) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).value;
                RESULT = new Multiplication(egleft + 1, eg, ed);
                CUP$AnalyseurSyntaxique$result = parser.getSymbolFactory().newSymbol("EXP", 9, ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 2)), ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), RESULT);
            }
            return CUP$AnalyseurSyntaxique$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 28: // EXP ::= EXP PLUS EXP
            {
                Expression RESULT = null;
                int egleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 2)).left;
                int egright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 2)).right;
                Expression eg = (Expression) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 2)).value;
                int edleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).left;
                int edright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).right;
                Expression ed = (Expression) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).value;
                RESULT = new Addition(egleft + 1, eg, ed);
                CUP$AnalyseurSyntaxique$result = parser.getSymbolFactory().newSymbol("EXP", 9, ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 2)), ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), RESULT);
            }
            return CUP$AnalyseurSyntaxique$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 27: // EXP ::= EXP INFERIEUR EXP
            {
                Expression RESULT = null;
                int egleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 2)).left;
                int egright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 2)).right;
                Expression eg = (Expression) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 2)).value;
                int edleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).left;
                int edright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).right;
                Expression ed = (Expression) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).value;
                RESULT = new Inferieur(egleft + 1, eg, ed);
                CUP$AnalyseurSyntaxique$result = parser.getSymbolFactory().newSymbol("EXP", 9, ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 2)), ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), RESULT);
            }
            return CUP$AnalyseurSyntaxique$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 26: // EXP ::= EXP DOUBLEEGAL EXP
            {
                Expression RESULT = null;
                int egleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 2)).left;
                int egright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 2)).right;
                Expression eg = (Expression) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 2)).value;
                int edleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).left;
                int edright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).right;
                Expression ed = (Expression) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).value;
                RESULT = new DoubleEgal(egleft + 1, eg, ed);
                CUP$AnalyseurSyntaxique$result = parser.getSymbolFactory().newSymbol("EXP", 9, ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 2)), ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), RESULT);
            }
            return CUP$AnalyseurSyntaxique$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 25: // EXP ::= EXP DIFFERENT EXP
            {
                Expression RESULT = null;
                int egleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 2)).left;
                int egright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 2)).right;
                Expression eg = (Expression) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 2)).value;
                int edleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).left;
                int edright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).right;
                Expression ed = (Expression) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).value;
                RESULT = new Different(egleft + 1, eg, ed);
                CUP$AnalyseurSyntaxique$result = parser.getSymbolFactory().newSymbol("EXP", 9, ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 2)), ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), RESULT);
            }
            return CUP$AnalyseurSyntaxique$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 24: // EXP ::= IDF PAROUVRANTE LEXP PARFERMANTE
            {
                Expression RESULT = null;
                int ileft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 3)).left;
                int iright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 3)).right;
                String i = (String) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 3)).value;
                int leleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).left;
                int leright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).right;
                ArrayList<Expression> le = (ArrayList<Expression>) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).value;
                RESULT = new AppelFonction(ileft + 1, i, le);
                CUP$AnalyseurSyntaxique$result = parser.getSymbolFactory().newSymbol("EXP", 9, ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 3)), ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), RESULT);
            }
            return CUP$AnalyseurSyntaxique$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 23: // EXP ::= IDF PAROUVRANTE PARFERMANTE
            {
                Expression RESULT = null;
                int ileft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 2)).left;
                int iright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 2)).right;
                String i = (String) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 2)).value;
                RESULT = new AppelFonction(ileft + 1, i);
                CUP$AnalyseurSyntaxique$result = parser.getSymbolFactory().newSymbol("EXP", 9, ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 2)), ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), RESULT);
            }
            return CUP$AnalyseurSyntaxique$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 22: // EXP ::= IDF
            {
                Expression RESULT = null;
                int ileft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).left;
                int iright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).right;
                String i = (String) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).value;
                RESULT = new Idf(i, ileft + 1);
                CUP$AnalyseurSyntaxique$result = parser.getSymbolFactory().newSymbol("EXP", 9, ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), RESULT);
            }
            return CUP$AnalyseurSyntaxique$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 21: // EXP ::= CSTBOOLEENNE
            {
                Expression RESULT = null;
                int cleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).left;
                int cright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).right;
                String c = (String) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).value;
                RESULT = new ConstanteBooleenne(c, cleft + 1);
                CUP$AnalyseurSyntaxique$result = parser.getSymbolFactory().newSymbol("EXP", 9, ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), RESULT);
            }
            return CUP$AnalyseurSyntaxique$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 20: // EXP ::= CSTENTIERE
            {
                Expression RESULT = null;
                int cleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).left;
                int cright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).right;
                String c = (String) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).value;
                RESULT = new ConstanteEntiere(c, cleft + 1);
                CUP$AnalyseurSyntaxique$result = parser.getSymbolFactory().newSymbol("EXP", 9, ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), RESULT);
            }
            return CUP$AnalyseurSyntaxique$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 19: // INST ::= REPETER LINST JUSQUA EXP FINREPETER
            {
                Instruction RESULT = null;
                int lileft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 3)).left;
                int liright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 3)).right;
                ArbreAbstrait li = (ArbreAbstrait) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 3)).value;
                int eleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).left;
                int eright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).right;
                Expression e = (Expression) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).value;
                RESULT = new Boucle(eleft + 1, e, li);
                CUP$AnalyseurSyntaxique$result = parser.getSymbolFactory().newSymbol("INST", 8, ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 4)), ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), RESULT);
            }
            return CUP$AnalyseurSyntaxique$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 18: // INST ::= SI EXP ALORS FINSI
            {
                Instruction RESULT = null;
                int eleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 2)).left;
                int eright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 2)).right;
                Expression e = (Expression) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 2)).value;
                RESULT = new Conditionnelle(eleft + 1, e, new BlocDInstructions(eleft + 1), new BlocDInstructions(eleft + 1));
                CUP$AnalyseurSyntaxique$result = parser.getSymbolFactory().newSymbol("INST", 8, ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 3)), ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), RESULT);
            }
            return CUP$AnalyseurSyntaxique$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 17: // INST ::= SI EXP ALORS LINST FINSI
            {
                Instruction RESULT = null;
                int eleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 3)).left;
                int eright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 3)).right;
                Expression e = (Expression) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 3)).value;
                int lialeft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).left;
                int liaright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).right;
                ArbreAbstrait lia = (ArbreAbstrait) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).value;
                RESULT = new Conditionnelle(eleft + 1, e, lia, new BlocDInstructions(eleft + 1));
                CUP$AnalyseurSyntaxique$result = parser.getSymbolFactory().newSymbol("INST", 8, ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 4)), ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), RESULT);
            }
            return CUP$AnalyseurSyntaxique$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 16: // INST ::= SI EXP ALORS SINON LINST FINSI
            {
                Instruction RESULT = null;
                int eleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 4)).left;
                int eright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 4)).right;
                Expression e = (Expression) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 4)).value;
                int lisleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).left;
                int lisright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).right;
                ArbreAbstrait lis = (ArbreAbstrait) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).value;
                RESULT = new Conditionnelle(eleft + 1, e, new BlocDInstructions(eleft + 1), lis);
                CUP$AnalyseurSyntaxique$result = parser.getSymbolFactory().newSymbol("INST", 8, ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 5)), ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), RESULT);
            }
            return CUP$AnalyseurSyntaxique$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 15: // INST ::= SI EXP ALORS LINST SINON LINST FINSI
            {
                Instruction RESULT = null;
                int eleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 5)).left;
                int eright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 5)).right;
                Expression e = (Expression) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 5)).value;
                int lialeft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 3)).left;
                int liaright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 3)).right;
                ArbreAbstrait lia = (ArbreAbstrait) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 3)).value;
                int lisleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).left;
                int lisright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).right;
                ArbreAbstrait lis = (ArbreAbstrait) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).value;
                RESULT = new Conditionnelle(eleft + 1, e, lia, lis);
                CUP$AnalyseurSyntaxique$result = parser.getSymbolFactory().newSymbol("INST", 8, ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 6)), ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), RESULT);
            }
            return CUP$AnalyseurSyntaxique$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 14: // INST ::= RETOURNE EXP POINTVIRGULE
            {
                Instruction RESULT = null;
                int eleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).left;
                int eright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).right;
                Expression e = (Expression) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).value;
                RESULT = new Retourne(eleft + 1, e);
                CUP$AnalyseurSyntaxique$result = parser.getSymbolFactory().newSymbol("INST", 8, ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 2)), ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), RESULT);
            }
            return CUP$AnalyseurSyntaxique$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 13: // INST ::= IDF EGAL EXP POINTVIRGULE
            {
                Instruction RESULT = null;
                int ileft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 3)).left;
                int iright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 3)).right;
                String i = (String) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 3)).value;
                int eleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).left;
                int eright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).right;
                Expression e = (Expression) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).value;
                RESULT = new Affect(new Idf(i, ileft + 1), e, eleft + 1);
                CUP$AnalyseurSyntaxique$result = parser.getSymbolFactory().newSymbol("INST", 8, ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 3)), ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), RESULT);
            }
            return CUP$AnalyseurSyntaxique$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 12: // INST ::= ECRIRE EXP POINTVIRGULE
            {
                Instruction RESULT = null;
                int eleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).left;
                int eright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).right;
                Expression e = (Expression) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).value;
                RESULT = new Ecrire(e, eleft + 1);
                CUP$AnalyseurSyntaxique$result = parser.getSymbolFactory().newSymbol("INST", 8, ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 2)), ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), RESULT);
            }
            return CUP$AnalyseurSyntaxique$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 11: // LDECL_LOC ::= DECL_LOC
            {
                ArbreAbstrait RESULT = null;
                int dleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).left;
                int dright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).right;
                ArbreAbstrait d = (ArbreAbstrait) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).value;

                CUP$AnalyseurSyntaxique$result = parser.getSymbolFactory().newSymbol("LDECL_LOC", 6, ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), RESULT);
            }
            return CUP$AnalyseurSyntaxique$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 10: // LDECL_LOC ::= LDECL_LOC DECL_LOC
            {
                ArbreAbstrait RESULT = null;
                int ldleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).left;
                int ldright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).right;
                ArbreAbstrait ld = (ArbreAbstrait) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).value;
                int dleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).left;
                int dright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).right;
                ArbreAbstrait d = (ArbreAbstrait) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).value;

                CUP$AnalyseurSyntaxique$result = parser.getSymbolFactory().newSymbol("LDECL_LOC", 6, ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)), ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), RESULT);
            }
            return CUP$AnalyseurSyntaxique$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 9: // LDECL_PARAM ::= DECL_PARAM
            {
                String RESULT = null;
                int dleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).left;
                int dright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).right;
                String d = (String) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).value;
                RESULT = d;
                CUP$AnalyseurSyntaxique$result = parser.getSymbolFactory().newSymbol("LDECL_PARAM", 12, ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), RESULT);
            }
            return CUP$AnalyseurSyntaxique$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 8: // LDECL_PARAM ::= LDECL_PARAM DECL_PARAM
            {
                String RESULT = null;
                int ldleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).left;
                int ldright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).right;
                String ld = (String) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).value;
                int dleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).left;
                int dright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).right;
                String d = (String) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).value;
                RESULT = ld + "," + d;
                CUP$AnalyseurSyntaxique$result = parser.getSymbolFactory().newSymbol("LDECL_PARAM", 12, ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)), ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), RESULT);
            }
            return CUP$AnalyseurSyntaxique$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 7: // LFONC ::= FONC
            {
                ArbreAbstrait RESULT = null;
                int fleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).left;
                int fright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).right;
                ArbreAbstrait f = (ArbreAbstrait) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).value;
                BlocDInstructions b = new BlocDInstructions(fleft + 1);
                b.ajouter(f);
                RESULT = b;
                CUP$AnalyseurSyntaxique$result = parser.getSymbolFactory().newSymbol("LFONC", 3, ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), RESULT);
            }
            return CUP$AnalyseurSyntaxique$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 6: // LFONC ::= LFONC FONC
            {
                ArbreAbstrait RESULT = null;
                int lfleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).left;
                int lfright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).right;
                ArbreAbstrait lf = (ArbreAbstrait) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).value;
                int fleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).left;
                int fright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).right;
                ArbreAbstrait f = (ArbreAbstrait) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).value;
                ((BlocDInstructions) lf).ajouter(f);
                RESULT = lf;
                CUP$AnalyseurSyntaxique$result = parser.getSymbolFactory().newSymbol("LFONC", 3, ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)), ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), RESULT);
            }
            return CUP$AnalyseurSyntaxique$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 5: // LINST ::= INST
            {
                ArbreAbstrait RESULT = null;
                int ileft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).left;
                int iright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).right;
                Instruction i = (Instruction) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).value;
                BlocDInstructions b = new BlocDInstructions(ileft + 1);
                b.ajouter(i);
                RESULT = b;
                CUP$AnalyseurSyntaxique$result = parser.getSymbolFactory().newSymbol("LINST", 1, ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), RESULT);
            }
            return CUP$AnalyseurSyntaxique$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 4: // LINST ::= LINST INST
            {
                ArbreAbstrait RESULT = null;
                int lileft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).left;
                int liright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).right;
                ArbreAbstrait li = (ArbreAbstrait) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).value;
                int ileft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).left;
                int iright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).right;
                Instruction i = (Instruction) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).value;
                ((BlocDInstructions) li).ajouter(i);
                RESULT = li;
                CUP$AnalyseurSyntaxique$result = parser.getSymbolFactory().newSymbol("LINST", 1, ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)), ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), RESULT);
            }
            return CUP$AnalyseurSyntaxique$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 3: // LDECL ::= DECL
            {
                ArbreAbstrait RESULT = null;
                int dleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).left;
                int dright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).right;
                ArbreAbstrait d = (ArbreAbstrait) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).value;

                CUP$AnalyseurSyntaxique$result = parser.getSymbolFactory().newSymbol("LDECL", 2, ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), RESULT);
            }
            return CUP$AnalyseurSyntaxique$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 2: // LDECL ::= LDECL DECL
            {
                ArbreAbstrait RESULT = null;
                int ldleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).left;
                int ldright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).right;
                ArbreAbstrait ld = (ArbreAbstrait) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).value;
                int dleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).left;
                int dright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).right;
                ArbreAbstrait d = (ArbreAbstrait) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()).value;

                CUP$AnalyseurSyntaxique$result = parser.getSymbolFactory().newSymbol("LDECL", 2, ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)), ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), RESULT);
            }
            return CUP$AnalyseurSyntaxique$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 1: // PROG ::= VARIABLES LDECL FONCTIONS LFONC DEBUT LINST FIN
            {
                ArbreAbstrait RESULT = null;
                int ldleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 5)).left;
                int ldright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 5)).right;
                ArbreAbstrait ld = (ArbreAbstrait) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 5)).value;
                int lfleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 3)).left;
                int lfright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 3)).right;
                ArbreAbstrait lf = (ArbreAbstrait) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 3)).value;
                int lileft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).left;
                int liright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).right;
                ArbreAbstrait li = (ArbreAbstrait) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).value;
                RESULT = li;
                CUP$AnalyseurSyntaxique$result = parser.getSymbolFactory().newSymbol("PROG", 0, ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 6)), ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), RESULT);
            }
            return CUP$AnalyseurSyntaxique$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 0: // $START ::= PROG EOF
            {
                Object RESULT = null;
                int start_valleft = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).left;
                int start_valright = ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).right;
                ArbreAbstrait start_val = (ArbreAbstrait) ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)).value;
                RESULT = start_val;
                CUP$AnalyseurSyntaxique$result = parser.getSymbolFactory().newSymbol("$START", 0, ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.elementAt(CUP$AnalyseurSyntaxique$top - 1)), ((java_cup.runtime.Symbol) CUP$AnalyseurSyntaxique$stack.peek()), RESULT);
            }
            /* ACCEPT */
            CUP$AnalyseurSyntaxique$parser.done_parsing();
            return CUP$AnalyseurSyntaxique$result;

            /* . . . . . .*/
            default:
                throw new Exception(
                        "Invalid action number found in internal parse table");

        }
    }
}

